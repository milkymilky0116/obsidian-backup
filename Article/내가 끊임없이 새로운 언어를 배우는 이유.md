
시작하기 전에, 이 글은 내가 배웠던 언어들에 대한 소개를 하려는 목적으로 쓰인 것이 아니다. 혹은 어떤 방법론에 대해서 설교하고자 쓰인 글은 더더욱 아니다. 이 글은 그저 호기심이 많은 주니어 개발자가 여러 프로그래밍 언어, 혹은 프레임워크 들을 여행하면서 얻었던 경험과 인사이트를 공유하고 싶다는 생각에서 출발하게 되었다. 
 

> "언어는 생각의 감옥인가?"

### 언어는 사고를 결정한다

테드 창의 **'네 인생의 이야기'** 를 원작으로 하는 영화 **[컨택트(Arrival)]** 는, 어느날 지구에 나타난 낯선 외계인 종족인 '헵타포드'와 소통하기 위해 언어학자인 '루이즈'가 그들의 언어를 배우기 시작한다. 헵타포드의 언어체계를 이해하면서 루이즈는 그들의 사고체계 마저 이해하게 됨으로써 헵타포드 종족과 점차 동화되기 시작한다.

조지오웰의 **[1984]** 에서는 영어를 인위적으로 가공한 신어(New word)라는 설정이 나온다. 어느 하나의 단어에 들어있는 여러 의미를 삭제하고 비유와 은유라는 개념을 삭제 하면서, 구성원들이 당에 대한 반역을 감히 상상할 수도 없게끔 만드는 '통제의 수단'으로써 등장한다.

위에서 소개한 두가지 작품은 모두 '언어적 상대성' (혹은 언어-사고 결정론)을 기반으로 쓰여졌다. 우리의 언어가 생각을 결정하고, 사고체계를 결정하며, 더 나아가 삶을 결정한다는 이론이다.

왜 느닷없이 프로그래밍 언어를 주제로 한 글에서 '언어적 상대성'을 설명하고 있는걸까. 혹시 프로그래밍 '언어' 이기 때문에 '언어적 상대성'이 프로그래밍 에도 적용 될 수 있다는 말장난 같은 근거를 내세우려고 하는 것일까? 

놀랍게도, 그렇다. 그리고 프로그래밍 언어 역시 사고를 결정할 수 있다고 나는 생각한다. 그리고 프로그래밍 언어 역시, 그 안에 담겨있는 철학적 차이가 사람에게 유의미한 영향을 끼친다고 생각한다. 다만 프로그래밍 언어가 영어, 일본어, 한국어 처럼 자연어가 아닐 뿐이다. 

> “**Languages are not just a communication system; it is a control system**,” “_How Language Programs the Mind_, G.Lupyan(2016)”


### 프로그래밍 언어를 배우면 보이는 것들

처음으로 프로그래밍 언어를 배웠던 때로 돌아가보자. 프로그래밍 언어가 생소한 여러분에게 이런 문제가 주어졌다고 생각해보자. 어떻게 풀 수 있을까?

> 문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다. (출처: 프로그래머스 '문자열 내 마음대로 정렬하기')

```
["sun", "bed", "car"]를 2번째 글자 기준으로 정렬 > ["car", "bed", "sun"]
["abce", "abcd", "cdx"]를 3번째 글자 기준으로 정렬 > ["abcd", "abce", "cdx"]
```

만약에 인간인 우리 입장에서 문제를 해결하고자 한다면 이런식으로 풀 것이다.

> ["sun", "bed", "car"] 라는 단어들이 주어졌을때, 음... 쭉 둘러보니까 "car"의 두번째 글자가 a 니까 첫번째로 가야하고.. 남은 bed과 sun을 비교했을때 e, u니까 ["car", "bed", "sun"] 순으로 정렬하면 되겠다.

하지만 이런 생각의 프로세스를 컴퓨터에게 전달하려면 어떻게 해야 될까? 여러분은 곧 난관에 봉착하게 된다.

>  1. 일단 컴퓨터에 입력값으로 넣을 '배열' 이라는 자료구조에 대한 이해가 필요하다.
>  2. 컴퓨터는 인간처럼 배열을 한눈에 둘러볼수가 없다. 항상 순차적으로 봐야한다.
>  3. 배열 안의 어떤 값을 보고 싶으면 그냥 볼 수 없고, 인덱싱이라는 것을 알아야 한다.
>  4. (프로그래밍 언어마다 다름) 단어도 직관적으로 그냥 쓱 볼 수 없고, 마치 배열처럼 인덱싱으로 접근해야 한다.

등등등...

프로그래밍 언어를 작성하기 위해서는 인간적인 직관에서 벗어나 컴퓨터가 이해할 수 있는 논리대로 작성해야 한다. 컴퓨터의 논리대로 작성하기 위해서는 컴퓨터만의 '사고'를 이해해야만 한다. 컴퓨터가 이해할 수 있는 형태만을 넣어야 하고, 컴퓨터가 세워놓은 규칙 아래에서 프로그래밍 언어를 기술해야 한다. 

여기서 '프로그래밍 언어의 사고 결정'은 명백하다. 프로그래밍 언어는 우리가 컴퓨터와 비슷한 생각을 가질 수 있도록 유도하고, 사고 체계를 결정한다. 마치 [컨택트]에서 헵타포드의 언어가 언어학자의 사고체계를 물들인 것 처럼 말이다. 

### 프로그래밍 언어, 저마다의 철학

대부분의 프로그래밍 언어의 공식 문서에는 '왜 우리가 이것을 만들었는지' 에 대한 제작자들의 철학이 기술되어 있다. Python은 다음과 같이 적혀있다.

> 아름다움이 추함보다 낫다. 
> 명시적인 것이 암시적인 것보다 낫다. 
> 단순함이 복잡함보다 낫다. 
> 복잡함이 난해함보다 낫다. 
> 평평함이 중첩된 것보다 낫다. 
> 드문드문 한 것이 밀집된 것보다 낫다. 
> 가독성이 중요하다. 
> ....

반면 Rust는 다음과 같이 기술되어 있다.

> (의역)
> ...
> 예를 들어 메모리 관리, 데이터 표현, 그리고 동시성과 같은 "시스템 레벨" 작업을 살펴봅시다. 그동안 이러한 프로그래밍 영역은 어렵고 난해하게 여겨져 왔으며 , 오직 "시스템 레벨" 작업을 몇년동안 배워온 선택된 사람들만 다룰 수 있는 영역으로 간주되었습니다. 심지어 이것을 실제로 사용하는 사람들도 그 코드가 취약점, 충돌 또는 손상에 노출되지 않도록 주의 깊게 사용해야 했습니다.
> 
> Rust는 이러한 장벽을 허물어내어 예전의 함정을 제거하고 여러분이 안전하게 프로그래밍할 수 있도록 친근하고 다듬어진 도구들을 제공함으로써 이 문제를 해결합니다. "저수준 제어"에 집중해야 하는 프로그래머들은 Rust를 사용하여 관행적으로 발생하는 충돌이나 보안 취약점의 위험을 감수하지 않고도 이를 수행할 수 있으며, 변덕스러운 도구 체인의 세부 사항을 배우지 않아도 됩니다. 게다가 언어는 신속하고 메모리 사용량 면에서 효율적인 신뢰성 있는 코드로 자연스럽게 이끌어주도록 설계되어 있습니다.
> ...

두 언어는 똑같은 프로그래밍 언어이지만, 어떤 문제를 해결하는지에 대한 방향성은 명백히 다르다. Python은 누구든지 쉽게 작성할 수 있는 쉽고 생산적인 프로그래밍을 위해 만들어졌다. Python은 '돌아가는 의사 코드(pseudo code)' 라고 불릴 만큼 간결한 문법과 구조를 가지고 있다. 

반면 Rust의 철학을 살펴보면 '안정성(stability)'에 대해 더 많이 포커스가 맞춰져 있는 것을 볼 수 있다. 이전의 Low-level(여기서 말하는 '저수준'은 컴퓨터와 밀접한 정도이다) 언어들을 사용하면서 감수해야 했던 메모리 안정성 문제를 해결하기 위해 등장했다.

프로그래밍 언어를 체득한다는 것은 그 언어에 깃들어 있는 철학을 습득하는 것과도 같다. 마치 우리가 일본어나 영어, 혹은 그 이외의 언어를 배울때 그 언어권의 문화를 이해하게 되는 것처럼 말이다.

Python으로는 이런 코드를 쓸 수 있다.

```python
def some_function_A(a):
	print(f"Hello {a}")

def some_function_B(b):
	print(f"How are you {b}?")
	
a = "milky"

some_function_A(a)
some_function_B(a)
```

반면 Rust에서 동일한 형태로 작성하면 어떻게 될까?

```rust
fn main() {
    let a = String::from("milky");
    some_function_a(a);
    some_function_b(a);
}

fn some_function_a(a: String) {
    println!("Hello {}", a)
}

fn some_function_b(b: String) {
    println!("How are you {}?", b)
}
```

안타깝게도 실행되지 않는다.

```
   Compiling my-project v0.1.0 (/home/runner/test)
    Building [                             ] 0/1: my
error[E0382]: use of moved value: `a`
 --> src/main.rs:4:21
  |
2 |     let a = String::from("milky");
  |         - move occurs because `a` has type `String`, which does not implement the `Copy` trait
3 |     some_function_a(a);
  |                     - value moved here
4 |     some_function_b(a);
  |                     ^ value used here after move
  |
note: consider changing this parameter type in function `some_function_a` to borrow instead if owning the value isn't necessary
...
```

이 글은 Rust에 관한 글이 아니기 때문에 자세하게 설명은 안하겠지만, 요지는 Rust는 Python에 반해 '안정성'을 크게 추구한 언어이기 때문에 Python에 존재하지 않는 새로운 개념이 존재한다. 그렇기에 Rust를 작성할때는 Python과는 다른 생각을 가지고 작성해야한다.

또 한가지 사례를 살펴보자. Python에서 배열을 순회하기 위해서는 다음과 같이 하면 된다.

```python
some_array = ["apple", "banana", "kiwi"]

for fruit in some_array:
  print(f"i want to eat {fruit}")
```


하지만 Elixir라는 언어에서는 이렇게 순회한다.

```elixir
defmodule CustomList do
	def len([]), do: []
	def len([head | tail]), do: IO.puts head
end
```

왜냐하면 Elixir에서는 배열을 Linked List로 간주하기 때문이다. 그렇기에 Elixir에서 리스트는 `[head | tail]` 로 나눌수 있다. tail은 또 다른 Linked List 이므로 똑같이 head와 tail로 나누어 재귀적으로 순회 할 수 있는 것이다. Elixir는 근본적으로 함수형 프로그래밍을 채택했기에 이런 구조를 선택했다.

> 이 부분에 대해 더 자세한 이야기를 보고 싶다면 제가 공부한 기록을 구경해보세요 ^^! [젤다](https://velog.io/@milkymilky0116/Today-I-Learned-23.03.1011) [젤다2](https://velog.io/@milkymilky0116/Today-I-Learned23.03.12)

이런 사례에서 보듯 프로그래밍 언어들이 가지고 있는 철학들, 해결하고자 하는 문제들은 저마다 다르다. 언어를 기술하는 코더들은 그 언어만의 철학을 자연스럽게 습득하고, 그 언어가 가진 규칙대로 설계를 익힌다.

### 마치 여행을 떠나는 것처럼 배우기

지난 챕터까지는 일반적인 이야기를 했다면, 여기서부터는 '왜 항상 새로운 것을 배우고 싶어하는지'에 대해 개인적인 생각들을 이야기를 하려고 한다.

프로그래밍 세계에서 새로운 것을 배운다는 것은 마치 '여행'을 가는 기분과도 같다고 생각한다. 앞서 말했듯, 프로그래밍 언어들은 저마다의 다른 철학을 가지고 있다. 그리고 다른 프로그래밍 언어를 배우면서 꼭 그 언어의 '전문가'가 될 필요는 없다고 생각한다. 마치 일본이나 미국으로 여행을 갔다오고 나서 일본어나 영어 마스터가 되는게 아닌 것처럼 말이다.

하지만 프로그래밍 언어의 장점은 그런 철학을 다른 언어에도 '적용' 해볼 수 있다는 것에 있다. 그리고 그런 점이 사고를 더 성장 할 수 있게 만든다고 생각한다. 가령 위의 Python과 Rust의 사례에서, Rust가 메모리 안정성을 위해 내세운 원칙을 Python에서도 비슷한 스타일로 적용해볼 수 있다. 그렇게 적용 해본다면 (어쩌면) Python으로 짠 프로그램의 안정성이 높아질지도 모른다.

혹은 어떤 문제에 있어서 재귀적으로 해결하는 것이 더 좋겠다고 판단이 들때, Elixir의 컨셉을 Python에서도 구현 해볼수 있다.
